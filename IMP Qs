1] Features of Python

**Definition:** Python is a high-level, interpreted programming language designed for readability and rapid development.

**Key features (write 6–8 points):**

* **Interpreted:** Code executes line-by-line; easier debugging (no compile step).
* **Readable & concise syntax:** Indentation defines blocks; code looks like pseudocode.
* **Dynamically typed:** Variables don’t require explicit type declarations.
* **Multi-paradigm:** Supports procedural, object-oriented and functional programming.
* **Extensive standard library & ecosystem:** NumPy, Pandas, Matplotlib, scikit-learn, etc.
* **Portable:** Runs on Windows, macOS, Linux without change.
* **Automatic memory management (garbage collection).**
* **Large community & third-party packages** — quick solutions and well-tested tools.

**Example sentence for answer:**
“Because Python is interpreted, dynamically typed and has a rich ecosystem (NumPy, Pandas, Matplotlib), it’s ideal for rapid development and data analysis in managerial contexts.”

---

2] Data types in Python

**Definition:** Python provides built-in data types grouped by purpose.

**Primary types (with short notes):**

* **Numeric:** `int` (e.g., `5`), `float` (e.g., `3.14`), `complex` (e.g., `2+3j`).
* **Text:** `str` — immutable sequence of characters (`"hello"`).
* **Boolean:** `bool` — `True`/`False`.
* **Sequence:** `list` (mutable, ordered), `tuple` (immutable, ordered), `range`.
* **Mapping:** `dict` — key:value pairs (`{'id':1, 'name':'A'}`).
* **Set types:** `set` (mutable, unique elements), `frozenset` (immutable set).
* **Binary:** `bytes`, `bytearray`.
* **Special:** `NoneType` (`None`).

**Exam tip:** Mention mutability for each: lists/dicts/sets are **mutable**; strings/tuples are **immutable**.

---

3] Conditional statements (if / elif / else)

**Purpose:** Execute different code blocks depending on boolean conditions.

**Syntax:**

```python
if condition1:
    # statements
elif condition2:
    # statements
else:
    # statements
```

**Important notes:**

* Use `and`, `or`, `not` for combining conditions.
* Indentation is mandatory (usually 4 spaces).
* `elif` allows multiple exclusive branches.

**Short example:**

```python
marks = 78
if marks >= 90:
    grade = "A+"
elif marks >= 75:
    grade = "A"
else:
    grade = "B"
```

**Exam tip:** Write a short example (3–4 lines) and explain `elif` is checked only if previous `if`/`elif` is false.

---

4] List

**Definition:** An ordered, mutable collection that can contain heterogeneous items.

**Creation & basic operations:**

```python
lst = [10, "apple", 3.14]
lst.append(20)    # add at end
lst.insert(1, 'x')# insert at index
lst.remove('apple') 
val = lst.pop()   # removes last element and returns it
lst.sort()        # sorts in place (elements must be comparable)
```

**Common methods:** `append`, `extend`, `insert`, `remove`, `pop`, `index`, `count`, `sort`, `reverse`, `clear`.

**Properties:**

* Mutable: elements can be changed.
* Ordered: preserves insertion order.
* Allows duplicates.

**Example use in data handling:** lists used for temporary data, converting to NumPy arrays or Pandas Series for analysis.

---

5] DataFrame (Pandas)

**Definition:** Two-dimensional labelled data structure (rows × columns), similar to a spreadsheet or SQL table.

**Creation:**

```python
import pandas as pd
df = pd.DataFrame({"Name": ["A","B"], "Sales":[100, 200]})
```

**Important operations (exam-worthy list):**

* `df.head(), df.tail()` — view sample rows
* `df.info(), df.describe()` — schema & summary stats
* `df.columns, df.shape` — metadata
* Selection: `df['col']`, `df[['c1','c2']]`, `df.loc[row_label]`, `df.iloc[row_pos]`
* Filtering: `df[df['Sales'] > 100]`
* Missing values: `df.isnull().sum()`, `df.dropna()`, `df.fillna()`
* Grouping/Aggregation: `df.groupby('Region')['Sales'].sum()`
* Merge/concat: `pd.merge(df1, df2, on='ID')`, `pd.concat([df1,df2])`

**Exam tip:** Give a small example of grouping or reading a CSV to show applied knowledge.

---

6] Mutable vs Immutable objects

**Definition & difference:**

* **Mutable:** object’s content can change after creation (e.g., `list`, `dict`, `set`). Example: `a=[1]; a.append(2)` modifies `a`.
* **Immutable:** object cannot be changed after creation (e.g., `int`, `float`, `str`, `tuple`). Example: `s="hi"; s[0]="H"` raises an error — you must create a new string.

**Why it matters:**

* Immutable objects are hashable and safe to use as keys in `dict`.
* Mutability affects function behavior when objects are passed (modifications inside functions affect the original object for mutable types).

**Short example to illustrate:**

```python
def change(x):
    x.append(4)    # modifies original list if mutable

lst = [1,2,3]
change(lst)       # lst becomes [1,2,3,4]
```

---

7] Python libraries (important ones & their use)

Write 5–6 major libraries and a one-line purpose for each:

* **NumPy:** numerical arrays, vectorized math, linear algebra (foundation for numeric computing).
* **Pandas:** data manipulation, DataFrame, cleaning, aggregation.
* **Matplotlib / Seaborn:** data visualization (plots & statistical visualization).
* **scikit-learn:** machine learning models, preprocessing, evaluation.
* **Statsmodels:** statistical tests & econometrics (optional mention).
* **Requests / BeautifulSoup:** web requests and HTML parsing (for data collection).

**Exam tip:** Mention relationships: “Pandas uses NumPy arrays under the hood; Matplotlib/Seaborn visualize Pandas DataFrames.”

---

8] Grouping statements (for / while loop)

**For loop (iterate known sequences):**

```python
for i in range(5):
    print(i)
```

* Use when iterating over items or a definite number of times.
* Can iterate lists, tuples, dict keys, DataFrame rows (`for idx, row in df.iterrows():` — but avoid for large dataframes).

**While loop (condition-based iteration):**

```python
i = 0
while i < 5:
    print(i)
    i += 1
```

* Use when iterations depend on a condition.

**Loop controls:**

* `break` — exit loop immediately.
* `continue` — skip rest of current iteration and continue.
* `else` on loops — executes if loop did not encounter `break`.

**Example (break/continue):**

```python
for n in range(10):
    if n == 5:
        break
    if n % 2 == 0:
        continue
    print(n)  # prints odd numbers until 5
```

---

## 9] Operators (categories & examples)

**Categories:**

* **Arithmetic:** `+ - * / // % **` (e.g., `5**2 = 25`)
* **Relational / Comparison:** `== != > < >= <=`
* **Logical:** `and`, `or`, `not`
* **Assignment:** `=, +=, -=, *=, /=`
* **Membership:** `in`, `not in` (e.g., `'a' in 'cat'`)
* **Identity:** `is`, `is not` (checks same object)
* **Bitwise:** `& | ^ << >>` (bit-level operations; less common for managers)

**Example usage in data filters:**

```python
df[(df['Age'] > 30) & (df['City'] == 'Delhi')]
```

---

# PRACTICAL (detailed, with code + explanation)

> Each practical includes: **Problem**, **Approach**, **Code**, **Explanation / edge-cases**.

---

### Practical 1] Print multiplication table of any number

**Problem:** Print table (1–10) for input `n`.

**Approach:** Loop from 1 to 10 and multiply.

**Code:**

```python
n = int(input("Enter number: "))
for i in range(1, 11):
    print(f"{n} x {i} = {n * i}")
```

**Notes:** Works for negative numbers and zero. Use `range(1, 11)` for standard 10-entry table.

---

### Practical 2] Even or Odd

**Problem:** Check if integer is even or odd.

**Approach:** Use modulus `% 2`.

**Code:**

```python
n = int(input("Enter integer: "))
if n % 2 == 0:
    print("Even")
else:
    print("Odd")
```

**Edge cases:** Works for negative integers as well; odd/even property unaffected by sign.

---

### Practical 3] Prime or Not

**Problem:** Determine whether a number is prime.

**Approach:**

* Edge cases: numbers ≤ 1 are not prime.
* Check divisibility from 2 to `sqrt(n)` (efficient).

**Code:**

```python
n = int(input("Enter integer: "))
if n <= 1:
    print("Not prime")
else:
    is_prime = True
    i = 2
    while i * i <= n:
        if n % i == 0:
            is_prime = False
            break
        i += 1
    print("Prime" if is_prime else "Not prime")
```

**Complexity:** O(√n). Efficient for typical lab inputs.

---

### Practical 4] If-else (bonus style — nested/graded)

**Problem:** Grade assignment based on marks.

**Approach:** Use `if-elif-else` with descending checks.

**Code:**

```python
marks = float(input("Enter marks (0-100): "))
if marks < 0 or marks > 100:
    print("Invalid marks")
elif marks >= 90:
    print("Grade: A+")
elif marks >= 75:
    print("Grade: A")
elif marks >= 60:
    print("Grade: B")
elif marks >= 40:
    print("Grade: C")
else:
    print("Grade: Fail")
```

**Notes:** Validate input range to avoid invalid marks.

---

### Practical 5] Positive / Negative / Zero

**Problem:** Classify number sign.

**Code:**

```python
n = float(input("Enter number: "))
if n > 0:
    print("Positive")
elif n < 0:
    print("Negative")
else:
    print("Zero")
```

---

### Practical 6] List functions — remove duplicates and sort (important)

**Problem:** Given a list, remove duplicates — optionally preserve original order — then sort.

**Approach:**

* Using `set()` is simplest but does not preserve order.
* To preserve order: iterate and remember seen items.

**Code (two ways):**

```python
lst = [3,1,2,3,4,1,5]

# Method A: simplest — unique sorted (order not preserved)
unique_sorted = sorted(set(lst))
print("Unique sorted:", unique_sorted)

# Method B: preserve first-occurrence order, then sort
seen = set()
unique_preserve = []
for x in lst:
    if x not in seen:
        unique_preserve.append(x)
        seen.add(x)
unique_preserve.sort()
print("Unique preserved then sorted:", unique_preserve)
```

**Explanation:**

* `set()` removes duplicates but unordered; `sorted()` gives ascending order.
* The second method first removes duplicates while preserving first appearance, then sorts; helpful when you need original-first occurrence semantics before ordering.

---

### Practical 7] Refer to midterm exam (typical combined question)

**Typical task:** Read a CSV, clean (drop NA, remove duplicates), create a grouped summary and save result.

**Code (concise pipeline):**

```python
import pandas as pd

df = pd.read_csv("midterm_data.csv")
df.drop_duplicates(inplace=True)
df.dropna(subset=['essential_column'], inplace=True)     # remove rows missing essential data
df['Date'] = pd.to_datetime(df['Date'], errors='coerce') # parse dates

# Example groupby: total sales per region
summary = df.groupby('Region')['Sales'].sum().reset_index()
summary.to_csv("midterm_summary.csv", index=False)
```

**Exam tip:** Explain each step: why drop duplicates, why convert date, why fill or drop missing values.

---

### Practical 8] List elements (basic list operations)

**Summary code showing common operations:**

```python
lst = [10,20,30,40]
print("Length:", len(lst))
print("Slicing [1:3]:", lst[1:3])
for i, item in enumerate(lst):
    print(i, item)
lst.append(50)
lst.extend([60,70])
lst.remove(30)
print("Final:", lst)
```

**Exam tip:** Mention time complexities for `append()` (amortized O(1)) and `remove()` (O(n)) if asked.

---

### Practical 9] Create a dictionary and print / delete / copy (important)

**Code:**

```python
d = {'name': 'Vaibhavi', 'age': 22, 'dept': 'CS'}
print("Original:", d)

# Add or update
d['salary'] = 50000
d['age'] = 23   # update

# Copy (shallow)
d_copy = d.copy()
print("Copy:", d_copy)

# Delete a key
del d['dept']   # or d.pop('dept')
print("After deletion:", d)

# Iterate keys and values
for k, v in d.items():
    print(k, v)
```

**Notes:** Use `d.pop('key', default)` to avoid KeyError if key may not exist.

---

### Practical 10] NumPy — 1D statistics and 2D array operations

**1D statistical analysis (all common stats):**

```python
import numpy as np

arr = np.array([10, 20, 30, 40, 50])
print("Mean:", arr.mean())
print("Median:", np.median(arr))
print("Std dev:", arr.std(ddof=0))   # population std
print("Variance:", arr.var())
print("Min, Max, Sum:", arr.min(), arr.max(), arr.sum())
print("Percentiles (25, 50, 75):", np.percentile(arr, [25, 50, 75]))
```

**2D array arithmetic (element-wise & matrix multiply):**

```python
A = np.array([[1,2],[3,4]])
B = np.array([[5,6],[7,8]])

print("A + B =\n", A + B)            # element-wise addition
print("A - B =\n", A - B)            # element-wise subtraction
print("A * B =\n", A * B)            # element-wise multiplication
print("Matrix multiply A.dot(B) =\n", A.dot(B))  # linear algebraic product
print("Transpose A.T =\n", A.T)
```

**Exam tip:** Mention difference between `A * B` (element-wise) and `A.dot(B)` (matrix multiplication).

---

### Practical 11] Given one file — full preprocessing pipeline (remove duplicates, standardize, identify problematic columns)

**Comprehensive step-by-step code:**

```python
import pandas as pd
from sklearn.preprocessing import StandardScaler
import re

# 1. Load file
df = pd.read_csv("given_file.csv")

# 2. Quick overview
print(df.shape)
print(df.info())
print(df.isnull().sum())

# 3. Remove duplicates
df = df.drop_duplicates()

# 4. Identify problematic columns
problem_cols = {}
for col in df.columns:
    missing = df[col].isnull().sum()
    dtype = df[col].dtype
    sample = df[col].dropna().astype(str).head(5).tolist()
    # detect special chars for string columns
    special_chars = False
    if dtype == object:
        joined = " ".join(sample)
        if re.search(r"[^A-Za-z0-9\s\-\_\,\./:]", joined):  # simple heuristic
            special_chars = True
    problem_cols[col] = {"missing": missing, "dtype": str(dtype), "special_chars": special_chars, "sample": sample}

print(pd.DataFrame.from_dict(problem_cols, orient='index'))

# 5. Handle missing values
num_cols = df.select_dtypes(include=['number']).columns.tolist()
cat_cols = df.select_dtypes(include=['object']).columns.tolist()

# Numeric: fill with mean or median
for c in num_cols:
    if df[c].isnull().sum() > 0:
        df[c].fillna(df[c].median(), inplace=True)  # median is robust to outliers

# Categorical: fill with mode or 'Unknown'
for c in cat_cols:
    if df[c].isnull().sum() > 0:
        df[c].fillna(df[c].mode().iloc[0] if not df[c].mode().empty else "Unknown", inplace=True)

# 6. Remove or fix special characters (example fix: keep alphanumerics and common punctuation)
for c in cat_cols:
    df[c] = df[c].astype(str).apply(lambda s: re.sub(r"[^A-Za-z0-9\s\-\_\,\./:]", "", s).strip())

# 7. Format date columns (attempt conversion for columns likely to be dates)
for c in df.columns:
    if 'date' in c.lower() or df[c].dtype == 'object' and df[c].str.match(r'\d{4}-\d{2}-\d{2}').any():
        df[c] = pd.to_datetime(df[c], errors='coerce')

# 8. Standardize numeric columns
scaler = StandardScaler()
if len(num_cols) > 0:
    df[num_cols] = scaler.fit_transform(df[num_cols])

# 9. Save cleaned file
df.to_csv("given_file_cleaned.csv", index=False)
print("Saved given_file_cleaned.csv")
```

**Explanation & exam rationale:**

* Use `median` for numeric imputation if outliers exist; otherwise `mean`.
* For categorical fill with `mode` or explicit label `'Unknown'`.
* Standardization (z-score) centers variables (mean=0, sd=1) — mention `StandardScaler`.
* Explain why you might drop a column (e.g., >50% missing or irrelevant/ID column).

---

### Practical 12] Visualization — Bar chart & Pie chart after groupby

**Problem:** Group data by a categorical column and plot bar and pie charts.

**Code:**

```python
import pandas as pd
import matplotlib.pyplot as plt

# Example dataframe
df = pd.DataFrame({
    'Category': ['A','B','A','C','B','A'],
    'Sales': [100, 200, 150, 120, 80, 170]
})

# Group by category
grp = df.groupby('Category')['Sales'].sum()

# Bar chart
fig, ax = plt.subplots(figsize=(6,4))
grp.plot(kind='bar', ax=ax)
ax.set_title('Sales by Category')
ax.set_xlabel('Category')
ax.set_ylabel('Sales')
plt.tight_layout()
plt.show()

# Pie chart
fig, ax = plt.subplots(figsize=(6,6))
grp.plot(kind='pie', autopct='%1.1f%%', startangle=90, ax=ax)
ax.set_ylabel('')  # remove y-label for pie
ax.set_title('Sales Share by Category')
plt.tight_layout()
plt.show()
```

**Visualization tips for labs/exams:**

* Always label axes and title figures.
* Use `tight_layout()` to avoid overlap.
* For pie charts, include `autopct` to show percentages.

